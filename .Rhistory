setwd("~/Desktop/DataScience/CienciaDeDados/1.Big-Data-Analytics-com-R-e-Microsoft-Azure-Machine-Learning/15.Projeto-de-Classificação-com-R-e-Azure-ML_-_Risco_de_Credito_Clientes_Banco")
getwd()
## Carregando Pacotes
library(dplyr)
library(ggplot2)
library(ROSE)
library(randomForest)
#### Carregando e Convertendo os Dados
## Carrega o dataset antes da transformacao (baixado do Azure ML)
df <- read.csv("German_Credit_Card_UCI_-_dataset.csv")
head(df)
dim(df)
# Selecione apenas as variáveis do tipo caractere para conversão
colunas_chr <- sapply(df, is.character)
df <- mutate_if(df, colunas_chr, as.factor)
df$X1.1 <- as.factor(df$X1.1)
## Alterando o nome das variáveis (pesquisado na fonte)
names(df) <- c("CheckingAcctStat", "Duration", "CreditHistory", "Purpose", "CreditAmount", "SavingsBonds", "Employment",
"InstallmentRatePecnt", "SexAndStatus", "OtherDetorsGuarantors", "PresentResidenceTime", "Property", "Age",
"OtherInstallments", "Housing", "ExistingCreditsAtBank", "Job", "NumberDependents", "Telephone", "ForeignWorker", "CreditStatus")
head(df)
unique_values <- lapply(df, function(x) length(unique(x)))
## Exibir o número de valores únicos para cada variável
for (i in seq_along(unique_values)) {
cat("Variável:", names(unique_values)[i], "\n")
cat("Unique Values:", unique_values[[i]], "\n\n")
}
# Carregando funções
source("src/ClassTools.R")
toFactors <- c("Duration", "CreditAmount", "Age")
maxVals <- c(100, 1000000, 100)
facNames <- unlist(lapply(toFactors, function(x) paste(x, "_f", sep = "")))
df[, facNames] <- Map(function(x, y) quantize.num(df[, x], maxval = y), toFactors, maxVals)
head(df)
str(df)
summary(df)
# Forma 1 (Utilizando função de ClassTools - duplicando linhas)
df_balanceado1 <- df
df_balanceado1 <- equ.Frame(df_balanceado1, 2)
df <- df_balanceado1
# Exibindo diversos comparativos de bom pagador ou não dependendo da variável
plots <- lapply(colNames2, function(x) {
if (x %in% names(df)) {
if (is.factor(df[[x]])) {
ggplot(df, aes(x = .data[[x]], fill = CreditStatus)) +
geom_bar() +
facet_grid(. ~ CreditStatus) +
ggtitle(paste("Total de Crédito Bom/Ruim por", x))
} else {
ggplot() +
ggtitle(paste("Coluna", x, "não é fator nem numérica. Não é possível criar gráfico."))
}
} else {
ggplot() +
ggtitle(paste("Coluna", x, "não existe no dataframe."))
}
})
print(plots)
modelo <- randomForest(CreditStatus ~ .
- Duration
- Age
- CreditAmount,
data = df,
ntree = 100, nodesize = 10, importance = T)
# Visualizando por números
print(modelo$importance)
# forma 3 (usando ggplot, método mais profissional)
importancia_ordenada <- modelo$importance[order(-modelo$importance[, 1]), , drop = FALSE]
df_importancia <- data.frame(
Variavel = rownames(importancia_ordenada),
Importancia = importancia_ordenada[, 1]
)
ggplot(df_importancia, aes(x = reorder(Variavel, -Importancia), y = Importancia)) +
geom_bar(stat = "identity", fill = "skyblue") +
labs(title = "Importância das Variáveis", x = "Variável", y = "Importância") +
theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10))
modelo <- randomForest(CreditStatus ~
CheckingAcctStat + Duration_f + CreditHistory + SavingsBonds +
CreditAmount_f + Property + Employment + Purpose,
data = df,
ntree = 100, nodesize = 10, importance = T)
# forma 3 (usando ggplot, método mais profissional)
importancia_ordenada <- modelo$importance[order(-modelo$importance[, 1]), , drop = FALSE]
df_importancia <- data.frame(
Variavel = rownames(importancia_ordenada),
Importancia = importancia_ordenada[, 1]
)
ggplot(df_importancia, aes(x = reorder(Variavel, -Importancia), y = Importancia)) +
geom_bar(stat = "identity", fill = "skyblue") +
labs(title = "Importância das Variáveis", x = "Variável", y = "Importância") +
theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10))
modelo <- randomForest(CreditStatus ~ .
- Duration
- Age
- CreditAmount,
data = df,
ntree = 100, nodesize = 10, importance = T)
# forma 1 (quanto mais a direita melhor)
varImpPlot(modelo)
# forma 2 (quando tem poucas variáveis)
barplot(modelo$importance[, 1], main = "Importância das Variáveis", col = "skyblue")
importancia_ordenada <- modelo$importance[order(-modelo$importance[, 1]), , drop = FALSE]
df_importancia <- data.frame(
Variavel = rownames(importancia_ordenada),
Importancia = importancia_ordenada[, 1]
)
ggplot(df_importancia, aes(x = reorder(Variavel, -Importancia), y = Importancia)) +
geom_bar(stat = "identity", fill = "skyblue") +
labs(title = "Importância das Variáveis", x = "Variável", y = "Importância") +
theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1, size = 10))
# Cross Tabulation
table(df$CreditStatus)
View(df)
# Gerando dados de treino e de teste
splits <- splitData(Credit, seed = 808)
# Funcao para gerar dados de treino e dados de teste
splitData <- function(dataframe, seed = NULL) {
if (!is.null(seed)) set.seed(seed)
index <- 1:nrow(dataframe)
trainindex <- sample(index, trunc(length(index)/2))
trainset <- dataframe[trainindex, ]
testset <- dataframe[-trainindex, ]
list(trainset = trainset, testset = testset)
}
# Gerando dados de treino e de teste
splits <- splitData(df, seed = 808)
# Separando os dados
dados_treino <- splits$trainset
dados_teste <- splits$testset
# Verificando o numero de linhas
nrow(dados_treino)
nrow(dados_teste)
# Verificando o numero de linhas
nrow(dados_treino)
nrow(dados_teste)
# Construindo o modelo
modelo <- randomForest( CreditStatus ~ CheckingAcctStat
+ Duration_f
+ Purpose
+ CreditHistory
+ SavingsBonds
+ Employment
+ CreditAmount_f,
data = dados_treino,
ntree = 100,
nodesize = 10)
# Imprimondo o resultado
print(modelo)
# Gerando previsões nos dados de teste
previsoes <- data.frame(observado = dados_teste$CreditStatus,
previsto = predict(modelo, newdata = dados_teste))
# Visualizando o resultado
head(previsoes)
head(dados_teste)
# Visualizando o resultado
head(previsoes)
# Gerando previsões nos dados de teste
previsoes <- data.frame(observado = dados_teste$CreditStatus,
previsto = predict(modelo, newdata = dados_teste))
# Visualizando o resultado
head(previsoes)
# Visualizando o resultado
View(previsoes)
# Formulas
Accuracy <- function(x){
(x[1,1] + x[2,2]) / (x[1,1] + x[1,2] + x[2,1] + x[2,2])
}
Recall <- function(x){
x[1,1] / (x[1,1] + x[1,2])
}
Precision <- function(x){
x[1,1] / (x[1,1] + x[2,1])
}
W_Accuracy  <- function(x){
(x[1,1] + x[2,2]) / (x[1,1] + 5 * x[1,2] + x[2,1] + x[2,2])
}
F1 <- function(x){
2 * x[1,1] / (2 * x[1,1] + x[1,2] + x[2,1])
}
# Criando a confusion matrix.
confMat <- matrix(unlist(Map(function(x, y){sum(ifelse(previsoes[, 1] == x & previsoes[, 2] == y, 1, 0) )},
c(2, 1, 2, 1), c(2, 2, 1, 1))), nrow = 2)
confMat
# Criando um dataframe com as estatisticas dos testes
df_mat <- data.frame(Category = c("Credito Ruim", "Credito Bom"),
Classificado_como_ruim = c(confMat[1,1], confMat[2,1]),
Classificado_como_bom = c(confMat[1,2], confMat[2,2]),
Accuracy_Recall = c(Accuracy(confMat), Recall(confMat)),
Precision_WAcc = c(Precision(confMat), W_Accuracy(confMat)))
print(df_mat)
# Gerando uma curva ROC em R
install.packages("ROCR", dependencies = TRUE)
library("ROCR")  # Gerando uma curva ROC em R
library(ROCR)  # Gerando uma curva ROC em R
print(df_mat)
library(caret) # Cria confusion matrix
## Confusion Matrix (utilizando pacote Caret)
confusionMatrix(previsoes$observado, previsoes$previsto)
# Imprimondo o resultado
print(modelo)
print(df_mat)
## Confusion Matrix (utilizando pacote Caret)
confusionMatrix(previsoes$observado, previsoes$previsto)
# Gerando as classes de dados
class1 <- predict(modelo, newdata = dados_teste, type = 'prob')
class2 <- dados_teste$CreditStatus
# Criando curva
pred <- prediction(class1[,2], class2)
perf <- performance(pred, "tpr","fpr")
plot(perf, col = rainbow(10))
